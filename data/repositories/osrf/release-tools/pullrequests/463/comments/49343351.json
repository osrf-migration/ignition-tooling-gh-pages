{"links": {"self": {"href": "data/repositories/osrf/release-tools/pullrequests/463/comments/49343351.json"}, "html": {"href": "#!/osrf/release-tools/pull-requests/463/_/diff#comment-49343351"}}, "parent": {"id": 49341404, "links": {"self": {"href": "data/repositories/osrf/release-tools/pullrequests/463/comments/49341404.json"}, "html": {"href": "#!/osrf/release-tools/pull-requests/463/_/diff#comment-49341404"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 463, "links": {"self": {"href": "data/repositories/osrf/release-tools/pullrequests/463.json"}, "html": {"href": "#!/osrf/release-tools/pull-requests/463"}}, "title": "Proposal: Updating to Visual Studio 2017 and improving Windows CI"}, "content": {"raw": "Some of what you describe as disadvantages I would actually consider advantages.\n\nWe should be giving the zip dependencies descriptive enough names that we don't have to change their names down the road, and so that different branches can choose which exact version of that dependency it intends to use. Consider this: the choice of which dependency to use is determined by the code that is using it; it is not determined by the name of the project. When a project migrates to a new dependency or wants to increment the version of one of its dependencies, we would currently have to handle this logic within `release-tools`, which can become difficult to maintain as time goes on and dependencies change. If we instead tie the dependencies' information directly to the changeset of the code that uses them, then all of that maintenance becomes trivial. As long as we make sure to not delete or rename the precompiled dependencies on AWS, we never need to worry about that upkeep. In the tragic circumstance that we do find a need to change the name of a dependency, we'll need to merge the name change into each branch of the project that is being tested by CI (which would be relatively few), and the rest of the branches can be forgotten.\n\nThe `configure.bat` scripts for many of the projects did not actually work outside of our CI unless the human user painstakingly recreated the procedure that is performed by the `release-tools` scripts. I actually think this is a great opportunity to create a script in release-tools that mimics the build process of the jenkins jobs, but without the test procedure. This way, we can just tell Windows users to run that script on their project directory, and it will take care of the build and installation with no effort for the user. We can give it some optional arguments, like where the install directory should be, and whether or not to build/run the tests.", "markup": "markdown", "html": "<p>Some of what you describe as disadvantages I would actually consider advantages.</p>\n<p>We should be giving the zip dependencies descriptive enough names that we don't have to change their names down the road, and so that different branches can choose which exact version of that dependency it intends to use. Consider this: the choice of which dependency to use is determined by the code that is using it; it is not determined by the name of the project. When a project migrates to a new dependency or wants to increment the version of one of its dependencies, we would currently have to handle this logic within <code>release-tools</code>, which can become difficult to maintain as time goes on and dependencies change. If we instead tie the dependencies' information directly to the changeset of the code that uses them, then all of that maintenance becomes trivial. As long as we make sure to not delete or rename the precompiled dependencies on AWS, we never need to worry about that upkeep. In the tragic circumstance that we do find a need to change the name of a dependency, we'll need to merge the name change into each branch of the project that is being tested by CI (which would be relatively few), and the rest of the branches can be forgotten.</p>\n<p>The <code>configure.bat</code> scripts for many of the projects did not actually work outside of our CI unless the human user painstakingly recreated the procedure that is performed by the <code>release-tools</code> scripts. I actually think this is a great opportunity to create a script in release-tools that mimics the build process of the jenkins jobs, but without the test procedure. This way, we can just tell Windows users to run that script on their project directory, and it will take care of the build and installation with no effort for the user. We can give it some optional arguments, like where the install directory should be, and whether or not to build/run the tests.</p>", "type": "rendered"}, "created_on": "2017-11-10T22:15:46.170807+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2017-11-10T22:16:41.215131+00:00", "type": "pullrequest_comment", "id": 49343351}